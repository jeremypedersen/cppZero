% BASIC SETTINGS
\documentclass[a4paper,12pt]{article} % Set paper size and document type
\usepackage{lmodern} % Use a slightly nicer looking font

% Change margins - default margins are too broad
\usepackage[margin=20mm]{geometry}

% SOURCE CODE LISTING SETTINGS 
% https://en.wikibooks.org/wiki/LaTeX/Source_Code_Listings
\usepackage{listings}
\usepackage{color}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

\lstset{ %
  backgroundcolor=\color{white},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}
  basicstyle=\footnotesize,        % the size of the fonts that are used for the code
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  breaklines=true,                 % sets automatic line breaking
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{mygreen},    % comment style
  deletekeywords={...},            % if you want to delete keywords from the given language
  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
  frame=single,	                   % adds a frame around the code
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  keywordstyle=\color{blue},       % keyword style
  otherkeywords={*,...},           % if you want to add more keywords to the set
  numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
  numbersep=5pt,                   % how far the line-numbers are from the code
  numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
  rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
  stepnumber=2,                    % the step between two line-numbers. If it's 1, each line will be numbered
  stringstyle=\color{mymauve},     % string literal style
  tabsize=2,	                   % sets default tabsize to 2 spaces
  title=\lstname                   % show the filename of files included with \lstinputlisting; also try caption instead of title
}

% PREPARE TITLE
\title{\textbf{Homework \#4 - Arrays and Vectors}}
\author{Name: }
\date{} % Hide the date

% START DOCUMENT
\begin{document}

\maketitle % Insert the title

\section{Intro}

In C++, there's no obvious replacement for the Python list. Probably the simplest thing C++ has that is like a list is the \textbf{array}. That said, there are two big differences between Python lists and C++ arrays:

\begin{itemize}
\item You must know the size of a C++ array before you use it
\item Everything in the array must be the same type (no mixing ints and strings)
\end{itemize}

\noindent
Here is some simple code to create an array of 10 integers in C++:

\vspace{5mm}
\lstinputlisting[language=C++, firstline=6]{fixedArray.cpp}

\noindent
We can get around the need to know in advance how big the array is by using C++'s \textbf{new} and \textbf{delete} operators. These let us ask the computer for more memory while the computer is running. See the example on the next page.

\clearpage

\vspace{5mm}
\lstinputlisting[language=C++, firstline=6]{dynamicArray.cpp}

\noindent
Here, we ask the user how large the array needs to be, and then \textbf{allocate} space in memory to hold it. 

\section{Vectors}

Using "new" and "delete" creates a lot of extra work for us! In the example above we had to create an integer pointer (int *) and then use new to ask the computer for memory. What happens if later on we need the array to grow again? Or we want to make a copy of it into a new place in computer memory? These situations will make our code ugly and difficult to read. Luckily someone has already thought of this and has written the "vector" library! This library takes care of asking for memory for us, and makes our lives much simpler. A simple program to read N numbers into a vector and print them back out would look like this (see next page):

\clearpage

\vspace{5mm}
\lstinputlisting[language=C++, firstline=6]{vectorUsage.cpp}

\noindent
See how much easier that is? No worrying about the final size of the vector, and no worrying about asking for more memory: the vector handles it all!

\section{Now you try}

\subsection{Arrays Challenge}

Use your new array knowledge to solve the arrays problem on HackerRank

\subsection{Vector Challenge}

Write a program which lets the user enter as many numbers as they want. When the user enters 9999, the program should stop and print out all the numbers that the user has entered so far. Like this:

\begin{verbatim}
Enter a number: 5
Enter a number: 25
Enter a number: 36
Enter a number: -4
Enter a number: 22
Enter a number: 9999
Your vector contains:
5 25 36 -4 22
\end{verbatim}

\end{document}